# Copyright 2025 Pasteur Labs. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Tesseract API module for wdm
# Generated by tesseract 0.9.0 on 2025-06-06T12:46:45.650559

from typing import Any

import equinox as eqx
import jax
import jax.numpy as jnp
from pydantic import BaseModel, Field
import mlflow
import matplotlib as mpl
import matplotlib.pyplot as plt

from tesseract_core.runtime import Array, Differentiable, Float64
from tesseract_core.runtime.tree_transforms import filter_func, flatten_with_paths

from spscml.whole_device_model.wrapper import solve_wdm
from spscml.fusion import fusion_power

jax.config.update("jax_enable_x64", True)
jax.config.update("jax_debug_nans", True)

#
# Schemata
#


# Note: This template uses equinox filter_jit to automatically treat non-array
# inputs/outputs as static. As Tesseract scalar objects (e.g. Float32) are
# essentially just wrappers around numpy 0D arrays, they will be considered to
# be dynamic and will be traced by JAX.
# If you want to treat scalar numerical values as static you will need to use
# built-in Python types (e.g. float, int) instead of Float32.


class InputSchema(BaseModel):
    # Initial conditions
    Vc0: Differentiable[Float64] = Field(
            description="Initial capacitor charge voltage [volts]"
    )
    Ip0: Differentiable[Float64] = Field(
            description="Initial plasma current [amperes]"
    )
    a0: Differentiable[Float64] = Field(
            description="Initial pinch radius [meters]"
    )

    # Plasma parameters
    N: Differentiable[Float64] = Field(
            description="Plasma linear density [meters^-1]"
    )
    Lp_prime: Differentiable[Float64] = Field(
            description="Plasma inductance per unit length [Henries / meter]"
    )
    Lz: Differentiable[Float64] = Field(
            description="Inter-electrode length [meters]"
    )

    # Circuit parameters
    R: Differentiable[Float64] = Field(
            description="Circuit resistance [Ohms]"
    )
    L: Differentiable[Float64] = Field(
            description="Circuit inductance [Henries]"
    )
    C: Differentiable[Float64] = Field(
            description="Capacitance [Farads]"
    )

    # Static inputs
    sheath_tesseract_url: str = Field(
            description="The tesseract to use when calculating the plasma current"
    )
    dt: float = Field(
            description="The step size to take in the simulation [seconds]"
    )
    t_end: float = Field(
            description="End time of the simulation [seconds]"
    )
    mlflow_parent_run_id: str | None = Field(
            default=None,
            description="The parent mlflow run id, if any"
    )


class OutputSchema(BaseModel):
    Q: Differentiable[Array[(None,), Float64]] = Field(
            description="ODE Solution: capacitor charge [coulombs]"
    )
    Ip: Differentiable[Array[(None,), Float64]] = Field(
            description="ODE Solution: plasma current [amperes]"
    )
    T: Differentiable[Array[(None,), Float64]] = Field(
            description="ODE Solution: plasma temperature [eV]"
    )
    n: Differentiable[Array[(None,), Float64]] = Field(
            description="ODE Solution: plasma density [meters**-3]"
    )
    Vp: Differentiable[Array[(None,), Float64]] = Field(
            description="ODE Solution: plasma voltage [volts]"
    )
    ts: Differentiable[Array[(None,), Float64]] = Field(
            description="ODE Solution: timestamps [seconds]"
    )


#
# Required endpoints
#


@eqx.filter_jit
def apply_jit(inputs: dict) -> dict:
    return solve_wdm(inputs)


def apply(inputs: InputSchema) -> OutputSchema:
    # Optional: Insert any pre-processing/setup that doesn't require tracing
    # and is only required when specifically running your apply function
    # and not your differentiable endpoints.
    # For example, you might want to set up a logger or mlflow server.
    # Pre-processing should not modify any input that could impact the
    # differentiable outputs in a nonlinear way (a constant shift
    # should be safe)

    with mlflow.start_run(run_name="Whole-device model solve", 
                          parent_run_id=inputs.mlflow_parent_run_id) as mlflow_run:
        inputs_dict = inputs.model_dump()
        inputs_dict['mlflow_run_id'] = mlflow_run.info.run_id

        for param in ["Vc0", "Ip0", "a0", "N", "Lp_prime", "Lz", 
                      "R", "L", "C"]:
            mlflow.log_param(param, inputs_dict[param])

        out = apply_jit(inputs_dict)

        mlflow.log_figure(circuit_plots(out), "plots/circuit.png")
        mlflow.log_figure(adiabat_plot(out, inputs.N, inputs.Lz), "plots/adiabat.png")
        mlflow.log_metric("TripleProduct", jnp.sum(out["n"] * out["T"] * inputs.dt))

    # Optional: Insert any post-processing that doesn't require tracing
    # For example, you might want to save to disk or modify a non-differentiable
    # output. Again, do not modify any differentiable output in a non-linear way.
    return out



#
# Jax-handled AD endpoints (no need to modify)
#


def jacobian(
    inputs: InputSchema,
    jac_inputs: set[str],
    jac_outputs: set[str],
):
    return jac_jit(inputs.model_dump(), tuple(jac_inputs), tuple(jac_outputs))


def jacobian_vector_product(
    inputs: InputSchema,
    jvp_inputs: set[str],
    jvp_outputs: set[str],
    tangent_vector: dict[str, Any],
):
    return jvp_jit(
        inputs.model_dump(),
        tuple(jvp_inputs),
        tuple(jvp_outputs),
        tangent_vector,
    )


def vector_jacobian_product(
    inputs: InputSchema,
    vjp_inputs: set[str],
    vjp_outputs: set[str],
    cotangent_vector: dict[str, Any],
):
    return vjp_jit(
        inputs.model_dump(),
        tuple(vjp_inputs),
        tuple(vjp_outputs),
        cotangent_vector,
    )


def abstract_eval(abstract_inputs):
    """Calculate output shape of apply from the shape of its inputs."""
    is_shapedtype_dict = lambda x: type(x) is dict and (x.keys() == {"shape", "dtype"})
    is_shapedtype_struct = lambda x: isinstance(x, jax.ShapeDtypeStruct)

    jaxified_inputs = jax.tree.map(
        lambda x: jax.ShapeDtypeStruct(**x) if is_shapedtype_dict(x) else x,
        abstract_inputs.model_dump(),
        is_leaf=is_shapedtype_dict,
    )
    dynamic_inputs, static_inputs = eqx.partition(
        jaxified_inputs, filter_spec=is_shapedtype_struct
    )

    def wrapped_apply(dynamic_inputs):
        inputs = eqx.combine(static_inputs, dynamic_inputs)
        return apply_jit(inputs)

    jax_shapes = jax.eval_shape(wrapped_apply, dynamic_inputs)
    return jax.tree.map(
        lambda x: (
            {"shape": x.shape, "dtype": str(x.dtype)} if is_shapedtype_struct(x) else x
        ),
        jax_shapes,
        is_leaf=is_shapedtype_struct,
    )


#
# Helper functions
#


@eqx.filter_jit
def jac_jit(
    inputs: dict,
    jac_inputs: tuple[str],
    jac_outputs: tuple[str],
):
    filtered_apply = filter_func(apply_jit, inputs, jac_outputs)
    return jax.jacrev(filtered_apply)(
        flatten_with_paths(inputs, include_paths=jac_inputs)
    )


@eqx.filter_jit
def jvp_jit(
    inputs: dict, jvp_inputs: tuple[str], jvp_outputs: tuple[str], tangent_vector: dict
):
    filtered_apply = filter_func(apply_jit, inputs, jvp_outputs)
    return jax.jvp(
        filtered_apply,
        [flatten_with_paths(inputs, include_paths=jvp_inputs)],
        [tangent_vector],
    )[1]


@eqx.filter_jit
def vjp_jit(
    inputs: dict,
    vjp_inputs: tuple[str],
    vjp_outputs: tuple[str],
    cotangent_vector: dict,
):
    filtered_apply = filter_func(apply_jit, inputs, vjp_outputs)
    _, vjp_func = jax.vjp(
        filtered_apply, flatten_with_paths(inputs, include_paths=vjp_inputs)
    )
    return vjp_func(cotangent_vector)[0]


## Plotting

def circuit_plots(out):
    ts = out["ts"]
    fig, axes = plt.subplots(2, 1, figsize=(10, 8), sharex=True)

    axes[0].plot(ts * 1e6, out["Ip"] / 1000, label="Plasma current [kA]")
    axes[0].set_ylabel("Plasma current [kA]")
    
    axes[1].plot(ts * 1e6, out["Vp"] / 1000)
    axes[1].set_ylabel("Voltage gap [kV]")
    axes[1].set_xlabel("Time [Âµs]")
    plt.tight_layout()

    return fig


def adiabat_plot(out, N, L):
    fig, ax = plt.subplots(1, 1, figsize=(10, 8))

    n = out["n"]
    T = out["T"]

    def fusion_power_of(n, T):
        a = jnp.sqrt(N / n / jnp.pi)
        return fusion_power(n, L, a, T)

    Ts = jnp.geomspace(0.7*jnp.min(T), 1.5*jnp.max(T), 100)
    ns = jnp.geomspace(0.7*jnp.min(n), 1.5*jnp.max(n), 100)
    n_mesh, T_mesh = jnp.meshgrid(ns, Ts)
    P_f = fusion_power_of(n_mesh, T_mesh)
    P_f_levels = jnp.geomspace(1e-6, 1e18, 13)
    
    cmap=plt.cm.plasma.copy()
    cmap.set_under('white')
    cf = ax.contourf(n_mesh, T_mesh, P_f, alpha=0.5, levels=P_f_levels,
                     cmap=cmap, norm=mpl.colors.LogNorm(vmin=1e-6, vmax=1e18), 
                     vmin=1e-6, vmax=1e18, extend='both')
    
    cbar = fig.colorbar(cf, extend='both')
    cbar.ax.set_ylabel("Fusion power [watts]")


    ax.loglog(n, T, color='blue')
    Ts = jnp.linspace(0.1*jnp.min(T), 10*jnp.max(T))
    for adiabat in 1.5**jnp.arange(-8, 8):
        ax.loglog((Ts/T[0])**(1.5) * n[0], Ts * adiabat, color='gray', linewidth=1.0)

    ax.set_xlim(0.7*jnp.min(n), 1.5*jnp.max(n))
    ax.set_ylim(0.7*jnp.min(T), 1.5*jnp.max(T))

    ax.set_xlabel("n [m^-3]")
    ax.set_ylabel("T [eV]")

    return fig
